// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/raids-lab/crater/dao/model"
)

func newImageAccount(db *gorm.DB, opts ...gen.DOOption) imageAccount {
	_imageAccount := imageAccount{}

	_imageAccount.imageAccountDo.UseDB(db, opts...)
	_imageAccount.imageAccountDo.UseModel(&model.ImageAccount{})

	tableName := _imageAccount.imageAccountDo.TableName()
	_imageAccount.ALL = field.NewAsterisk(tableName)
	_imageAccount.ID = field.NewUint(tableName, "id")
	_imageAccount.CreatedAt = field.NewTime(tableName, "created_at")
	_imageAccount.UpdatedAt = field.NewTime(tableName, "updated_at")
	_imageAccount.DeletedAt = field.NewField(tableName, "deleted_at")
	_imageAccount.ImageID = field.NewUint(tableName, "image_id")
	_imageAccount.AccountID = field.NewUint(tableName, "account_id")
	_imageAccount.Image = imageAccountBelongsToImage{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Image", "model.Image"),
		User: struct {
			field.RelationField
			UserAccounts struct {
				field.RelationField
			}
			UserDatasets struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Image.User", "model.User"),
			UserAccounts: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Image.User.UserAccounts", "model.UserAccount"),
			},
			UserDatasets: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Image.User.UserDatasets", "model.UserDataset"),
			},
		},
	}

	_imageAccount.Account = imageAccountBelongsToAccount{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Account", "model.Account"),
		UserAccounts: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Account.UserAccounts", "model.UserAccount"),
		},
		AccountDatasets: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Account.AccountDatasets", "model.AccountDataset"),
		},
	}

	_imageAccount.fillFieldMap()

	return _imageAccount
}

type imageAccount struct {
	imageAccountDo imageAccountDo

	ALL       field.Asterisk
	ID        field.Uint
	CreatedAt field.Time
	UpdatedAt field.Time
	DeletedAt field.Field
	ImageID   field.Uint
	AccountID field.Uint
	Image     imageAccountBelongsToImage

	Account imageAccountBelongsToAccount

	fieldMap map[string]field.Expr
}

func (i imageAccount) Table(newTableName string) *imageAccount {
	i.imageAccountDo.UseTable(newTableName)
	return i.updateTableName(newTableName)
}

func (i imageAccount) As(alias string) *imageAccount {
	i.imageAccountDo.DO = *(i.imageAccountDo.As(alias).(*gen.DO))
	return i.updateTableName(alias)
}

func (i *imageAccount) updateTableName(table string) *imageAccount {
	i.ALL = field.NewAsterisk(table)
	i.ID = field.NewUint(table, "id")
	i.CreatedAt = field.NewTime(table, "created_at")
	i.UpdatedAt = field.NewTime(table, "updated_at")
	i.DeletedAt = field.NewField(table, "deleted_at")
	i.ImageID = field.NewUint(table, "image_id")
	i.AccountID = field.NewUint(table, "account_id")

	i.fillFieldMap()

	return i
}

func (i *imageAccount) WithContext(ctx context.Context) IImageAccountDo {
	return i.imageAccountDo.WithContext(ctx)
}

func (i imageAccount) TableName() string { return i.imageAccountDo.TableName() }

func (i imageAccount) Alias() string { return i.imageAccountDo.Alias() }

func (i imageAccount) Columns(cols ...field.Expr) gen.Columns {
	return i.imageAccountDo.Columns(cols...)
}

func (i *imageAccount) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := i.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (i *imageAccount) fillFieldMap() {
	i.fieldMap = make(map[string]field.Expr, 8)
	i.fieldMap["id"] = i.ID
	i.fieldMap["created_at"] = i.CreatedAt
	i.fieldMap["updated_at"] = i.UpdatedAt
	i.fieldMap["deleted_at"] = i.DeletedAt
	i.fieldMap["image_id"] = i.ImageID
	i.fieldMap["account_id"] = i.AccountID

}

func (i imageAccount) clone(db *gorm.DB) imageAccount {
	i.imageAccountDo.ReplaceConnPool(db.Statement.ConnPool)
	return i
}

func (i imageAccount) replaceDB(db *gorm.DB) imageAccount {
	i.imageAccountDo.ReplaceDB(db)
	return i
}

type imageAccountBelongsToImage struct {
	db *gorm.DB

	field.RelationField

	User struct {
		field.RelationField
		UserAccounts struct {
			field.RelationField
		}
		UserDatasets struct {
			field.RelationField
		}
	}
}

func (a imageAccountBelongsToImage) Where(conds ...field.Expr) *imageAccountBelongsToImage {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a imageAccountBelongsToImage) WithContext(ctx context.Context) *imageAccountBelongsToImage {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a imageAccountBelongsToImage) Session(session *gorm.Session) *imageAccountBelongsToImage {
	a.db = a.db.Session(session)
	return &a
}

func (a imageAccountBelongsToImage) Model(m *model.ImageAccount) *imageAccountBelongsToImageTx {
	return &imageAccountBelongsToImageTx{a.db.Model(m).Association(a.Name())}
}

type imageAccountBelongsToImageTx struct{ tx *gorm.Association }

func (a imageAccountBelongsToImageTx) Find() (result *model.Image, err error) {
	return result, a.tx.Find(&result)
}

func (a imageAccountBelongsToImageTx) Append(values ...*model.Image) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a imageAccountBelongsToImageTx) Replace(values ...*model.Image) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a imageAccountBelongsToImageTx) Delete(values ...*model.Image) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a imageAccountBelongsToImageTx) Clear() error {
	return a.tx.Clear()
}

func (a imageAccountBelongsToImageTx) Count() int64 {
	return a.tx.Count()
}

type imageAccountBelongsToAccount struct {
	db *gorm.DB

	field.RelationField

	UserAccounts struct {
		field.RelationField
	}
	AccountDatasets struct {
		field.RelationField
	}
}

func (a imageAccountBelongsToAccount) Where(conds ...field.Expr) *imageAccountBelongsToAccount {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a imageAccountBelongsToAccount) WithContext(ctx context.Context) *imageAccountBelongsToAccount {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a imageAccountBelongsToAccount) Session(session *gorm.Session) *imageAccountBelongsToAccount {
	a.db = a.db.Session(session)
	return &a
}

func (a imageAccountBelongsToAccount) Model(m *model.ImageAccount) *imageAccountBelongsToAccountTx {
	return &imageAccountBelongsToAccountTx{a.db.Model(m).Association(a.Name())}
}

type imageAccountBelongsToAccountTx struct{ tx *gorm.Association }

func (a imageAccountBelongsToAccountTx) Find() (result *model.Account, err error) {
	return result, a.tx.Find(&result)
}

func (a imageAccountBelongsToAccountTx) Append(values ...*model.Account) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a imageAccountBelongsToAccountTx) Replace(values ...*model.Account) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a imageAccountBelongsToAccountTx) Delete(values ...*model.Account) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a imageAccountBelongsToAccountTx) Clear() error {
	return a.tx.Clear()
}

func (a imageAccountBelongsToAccountTx) Count() int64 {
	return a.tx.Count()
}

type imageAccountDo struct{ gen.DO }

type IImageAccountDo interface {
	gen.SubQuery
	Debug() IImageAccountDo
	WithContext(ctx context.Context) IImageAccountDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IImageAccountDo
	WriteDB() IImageAccountDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IImageAccountDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IImageAccountDo
	Not(conds ...gen.Condition) IImageAccountDo
	Or(conds ...gen.Condition) IImageAccountDo
	Select(conds ...field.Expr) IImageAccountDo
	Where(conds ...gen.Condition) IImageAccountDo
	Order(conds ...field.Expr) IImageAccountDo
	Distinct(cols ...field.Expr) IImageAccountDo
	Omit(cols ...field.Expr) IImageAccountDo
	Join(table schema.Tabler, on ...field.Expr) IImageAccountDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IImageAccountDo
	RightJoin(table schema.Tabler, on ...field.Expr) IImageAccountDo
	Group(cols ...field.Expr) IImageAccountDo
	Having(conds ...gen.Condition) IImageAccountDo
	Limit(limit int) IImageAccountDo
	Offset(offset int) IImageAccountDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IImageAccountDo
	Unscoped() IImageAccountDo
	Create(values ...*model.ImageAccount) error
	CreateInBatches(values []*model.ImageAccount, batchSize int) error
	Save(values ...*model.ImageAccount) error
	First() (*model.ImageAccount, error)
	Take() (*model.ImageAccount, error)
	Last() (*model.ImageAccount, error)
	Find() ([]*model.ImageAccount, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ImageAccount, err error)
	FindInBatches(result *[]*model.ImageAccount, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ImageAccount) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IImageAccountDo
	Assign(attrs ...field.AssignExpr) IImageAccountDo
	Joins(fields ...field.RelationField) IImageAccountDo
	Preload(fields ...field.RelationField) IImageAccountDo
	FirstOrInit() (*model.ImageAccount, error)
	FirstOrCreate() (*model.ImageAccount, error)
	FindByPage(offset int, limit int) (result []*model.ImageAccount, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IImageAccountDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (i imageAccountDo) Debug() IImageAccountDo {
	return i.withDO(i.DO.Debug())
}

func (i imageAccountDo) WithContext(ctx context.Context) IImageAccountDo {
	return i.withDO(i.DO.WithContext(ctx))
}

func (i imageAccountDo) ReadDB() IImageAccountDo {
	return i.Clauses(dbresolver.Read)
}

func (i imageAccountDo) WriteDB() IImageAccountDo {
	return i.Clauses(dbresolver.Write)
}

func (i imageAccountDo) Session(config *gorm.Session) IImageAccountDo {
	return i.withDO(i.DO.Session(config))
}

func (i imageAccountDo) Clauses(conds ...clause.Expression) IImageAccountDo {
	return i.withDO(i.DO.Clauses(conds...))
}

func (i imageAccountDo) Returning(value interface{}, columns ...string) IImageAccountDo {
	return i.withDO(i.DO.Returning(value, columns...))
}

func (i imageAccountDo) Not(conds ...gen.Condition) IImageAccountDo {
	return i.withDO(i.DO.Not(conds...))
}

func (i imageAccountDo) Or(conds ...gen.Condition) IImageAccountDo {
	return i.withDO(i.DO.Or(conds...))
}

func (i imageAccountDo) Select(conds ...field.Expr) IImageAccountDo {
	return i.withDO(i.DO.Select(conds...))
}

func (i imageAccountDo) Where(conds ...gen.Condition) IImageAccountDo {
	return i.withDO(i.DO.Where(conds...))
}

func (i imageAccountDo) Order(conds ...field.Expr) IImageAccountDo {
	return i.withDO(i.DO.Order(conds...))
}

func (i imageAccountDo) Distinct(cols ...field.Expr) IImageAccountDo {
	return i.withDO(i.DO.Distinct(cols...))
}

func (i imageAccountDo) Omit(cols ...field.Expr) IImageAccountDo {
	return i.withDO(i.DO.Omit(cols...))
}

func (i imageAccountDo) Join(table schema.Tabler, on ...field.Expr) IImageAccountDo {
	return i.withDO(i.DO.Join(table, on...))
}

func (i imageAccountDo) LeftJoin(table schema.Tabler, on ...field.Expr) IImageAccountDo {
	return i.withDO(i.DO.LeftJoin(table, on...))
}

func (i imageAccountDo) RightJoin(table schema.Tabler, on ...field.Expr) IImageAccountDo {
	return i.withDO(i.DO.RightJoin(table, on...))
}

func (i imageAccountDo) Group(cols ...field.Expr) IImageAccountDo {
	return i.withDO(i.DO.Group(cols...))
}

func (i imageAccountDo) Having(conds ...gen.Condition) IImageAccountDo {
	return i.withDO(i.DO.Having(conds...))
}

func (i imageAccountDo) Limit(limit int) IImageAccountDo {
	return i.withDO(i.DO.Limit(limit))
}

func (i imageAccountDo) Offset(offset int) IImageAccountDo {
	return i.withDO(i.DO.Offset(offset))
}

func (i imageAccountDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IImageAccountDo {
	return i.withDO(i.DO.Scopes(funcs...))
}

func (i imageAccountDo) Unscoped() IImageAccountDo {
	return i.withDO(i.DO.Unscoped())
}

func (i imageAccountDo) Create(values ...*model.ImageAccount) error {
	if len(values) == 0 {
		return nil
	}
	return i.DO.Create(values)
}

func (i imageAccountDo) CreateInBatches(values []*model.ImageAccount, batchSize int) error {
	return i.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (i imageAccountDo) Save(values ...*model.ImageAccount) error {
	if len(values) == 0 {
		return nil
	}
	return i.DO.Save(values)
}

func (i imageAccountDo) First() (*model.ImageAccount, error) {
	if result, err := i.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ImageAccount), nil
	}
}

func (i imageAccountDo) Take() (*model.ImageAccount, error) {
	if result, err := i.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ImageAccount), nil
	}
}

func (i imageAccountDo) Last() (*model.ImageAccount, error) {
	if result, err := i.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ImageAccount), nil
	}
}

func (i imageAccountDo) Find() ([]*model.ImageAccount, error) {
	result, err := i.DO.Find()
	return result.([]*model.ImageAccount), err
}

func (i imageAccountDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ImageAccount, err error) {
	buf := make([]*model.ImageAccount, 0, batchSize)
	err = i.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (i imageAccountDo) FindInBatches(result *[]*model.ImageAccount, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return i.DO.FindInBatches(result, batchSize, fc)
}

func (i imageAccountDo) Attrs(attrs ...field.AssignExpr) IImageAccountDo {
	return i.withDO(i.DO.Attrs(attrs...))
}

func (i imageAccountDo) Assign(attrs ...field.AssignExpr) IImageAccountDo {
	return i.withDO(i.DO.Assign(attrs...))
}

func (i imageAccountDo) Joins(fields ...field.RelationField) IImageAccountDo {
	for _, _f := range fields {
		i = *i.withDO(i.DO.Joins(_f))
	}
	return &i
}

func (i imageAccountDo) Preload(fields ...field.RelationField) IImageAccountDo {
	for _, _f := range fields {
		i = *i.withDO(i.DO.Preload(_f))
	}
	return &i
}

func (i imageAccountDo) FirstOrInit() (*model.ImageAccount, error) {
	if result, err := i.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ImageAccount), nil
	}
}

func (i imageAccountDo) FirstOrCreate() (*model.ImageAccount, error) {
	if result, err := i.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ImageAccount), nil
	}
}

func (i imageAccountDo) FindByPage(offset int, limit int) (result []*model.ImageAccount, count int64, err error) {
	result, err = i.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = i.Offset(-1).Limit(-1).Count()
	return
}

func (i imageAccountDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = i.Count()
	if err != nil {
		return
	}

	err = i.Offset(offset).Limit(limit).Scan(result)
	return
}

func (i imageAccountDo) Scan(result interface{}) (err error) {
	return i.DO.Scan(result)
}

func (i imageAccountDo) Delete(models ...*model.ImageAccount) (result gen.ResultInfo, err error) {
	return i.DO.Delete(models)
}

func (i *imageAccountDo) withDO(do gen.Dao) *imageAccountDo {
	i.DO = *do.(*gen.DO)
	return i
}
